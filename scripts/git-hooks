#!/usr/bin/env bash
set -euo pipefail

# Installer for git hooks in this repo.
# Usage:
#   ./scripts/git-hooks install   # symlink hooks/* into .git/hooks
#   ./scripts/git-hooks uninstall # remove installed symlinks
#
# The managed hooks live in scripts/hooks/<hook-name> (e.g., pre-commit).
# We symlink them into .git/hooks so they are used by git locally.

ROOT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
HOOKS_DIR="$ROOT_DIR/scripts/hooks"
GIT_DIR="$(git rev-parse --git-dir 2>/dev/null || true)"
if [ -z "$GIT_DIR" ]; then
  echo "Error: not inside a git repository" >&2
  exit 1
fi
TARGET_DIR="$GIT_DIR/hooks"

managed_hooks() {
  # List executable hook scripts we manage (exclude this installer file)
  find "$HOOKS_DIR" -maxdepth 1 -type f -perm -u+x -printf "%f\n" 2>/dev/null || {
    # macOS/BSD find fallback without -printf
    for f in "$HOOKS_DIR"/*; do
      [ -f "$f" ] || continue
      [ -x "$f" ] || continue
      basename "$f"
    done
  }
}

install_hooks() {
  mkdir -p "$TARGET_DIR"
  while IFS= read -r hook; do
    src="$HOOKS_DIR/$hook"
    dest="$TARGET_DIR/$hook"
    if [ -e "$dest" ] || [ -L "$dest" ]; then
      if [ "$(readlink "$dest" 2>/dev/null || true)" = "$src" ]; then
        echo "âœ“ $hook already installed"
        continue
      else
        mv -f "$dest" "$dest.bak"
        echo "Backed up existing $hook to $hook.bak"
      fi
    fi
    ln -s "$src" "$dest"
    echo "Installed $hook -> $src"
  done < <(managed_hooks)
  echo "Done."
}

uninstall_hooks() {
  local removed=false
  while IFS= read -r hook; do
    dest="$TARGET_DIR/$hook"
    if [ -L "$dest" ] && [ "$(readlink "$dest")" = "$HOOKS_DIR/$hook" ]; then
      rm -f "$dest"
      echo "Removed $hook"
      removed=true
    fi
  done < <(managed_hooks)
  if ! $removed; then
    echo "No managed hooks to remove."
  fi
}

case "${1:-}" in
  install)
    install_hooks
    ;;
  uninstall)
    uninstall_hooks
    ;;
  *)
    echo "Usage: $0 {install|uninstall|status}" >&2
    exit 2
    ;;
 esac
